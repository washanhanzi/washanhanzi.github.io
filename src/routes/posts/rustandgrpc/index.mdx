---
title: "A short journey with Rust and gRPC"
---

## Trait or not trait?

I'm a big fan of [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html), and coming from a background of `go`, when I think of using `rust` to write a gRPC service, I came up with the following folder structure in `/src`:

```
/controller
/entity
/repository
/usecase
main.rs
controller.rs
repository.rs
usecase.rs
```

For example, the `usecase.rs` file contains the trait `UseCase` and its implementation `UseCaseState`. Although the trait `UseCase` only has 1 implementation, I like to keep it as a trait for clearly showing all the interfaces of `UseCase`.

And because `UseCase` has only 1 implementation and the project will be a binary running on the server, the chance of another person using this trait is very low. So I want the trait to be static dispatching.

And the final code of `usecase.rs` looks like this:

```rust
use crate::repository::Repository;
use anyhow::Result;
use async_trait::async_trait;

mod delete;
mod get;
mod update;

#[async_trait]
pub trait UseCase {
	//get something
    async fn get(&self, key: &str) -> Result<String>;
	//update something
    async fn update(&self, k: &str, v: &str) -> Result<()>;
	//delete something
    async fn delete(&self, k: &str) -> Result<()>;
}

pub struct UseCaseState<Repository> {
    repo: Repository,
}

impl<T: Repository> UseCaseState<T> {
    pub async fn new(repo: T) -> Self {
        UseCaseState { repo, client }
    }
}

#[async_trait]
impl<T> UseCase for UseCaseState<T>
where
    T: Repository + Sync + Send,
{
    async fn get(&self, key: &str) -> Result<String> {
        Ok(self.get_uc(key).await?)
    }

    async fn update(&self, k: &str, v: &str) -> Result<()> {
        Ok(self.update_uc(k, v).await?)
    }
    async fn delete(&self, k: &str) -> Result<()> {
        Ok(self.delete_uc(k).await?)
    }
}
```

The reason to do this is I want to make the code more readable, so I separate the `UseCase` implementation into multiple files in `/usecase` folder, containing the `get_uc`, `update_uc` and `delete_uc` functions. You can see them from the three `mod` lines at the beginning.

I must say this results in a lot of boilerplate code.

And I am only a beginner of `rust`, it is definitely not pleasant to write the trait bounds and lifetime specifier for generic in trait implementation.

And the final docker image size is about `140Mb`.

So I told myself maybe I can remove all the `static dispatching` and `async_trait` stuff. I can tell after removing those things, the code becomes much cleaner and the final docker image size is only about `60Mb`, almost halving the build size.

The code without trait:

```rust
use crate::repository::RepositoryState;

mod delete;
mod get;
mod update;

pub struct UseCaseState {
    repo: RepositoryState,
}

impl UseCaseState {
    pub async fn new(repo: RepositoryState) -> Self {
        UseCaseState { repo, client }
    }
}
```

But maybe I can try `dynamic dispatching`, and compare the runtime performance with the `without trait` version.

I can barely survive with trait bound and lifetime in `static dispatching`, and those two things in dynamic dispatching is killing me.

I can see no benifits of using trait with only 1 implementation.

I think now I can only rely on my IDE to check all the implementation of a struct. This also let me reconsider whether I can remove all the `interface` in `go`,

## Error handling

I find a not so good looking pattern in handling errors, just like this code snippet from [rust official doc](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html):

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
```

It is kind of a `match hell`, instead of numerous `if err != nil` in `go`, it is a `match` with an `err` arm (good luck for another nested `match` and maybe another...).

At first I think the `?` operator will simplify the error handling, but it looks like it only works in simple cases.

## A Tiny problem with Rust Analyzer

When generating `rust` code from `proto` file, we will utilize `tonic` with `build.rs`. The default location for the generated code will be at somewhere like `target/debug/build/your_project_name-xxxxxxx/out/proto_package_name.rs`.

Since I'm a beginner at `rust`, I have the urge to look at the generated code, but `rust analyzer` will disappoint me as it always direct me to the `include!` clause. As stated in this [issue](https://github.com/rust-lang/rust-analyzer/issues/3767). (+1 for `CLion`)

## Interceptors
